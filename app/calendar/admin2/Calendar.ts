import { useState, useEffect } from "react";
import { Amplify } from "aws-amplify";
import outputs from "@/amplify_outputs.json";
import moment from "moment";
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource"; // Path to the schema generated by Amplify
import { Sanitize } from "../../supportFunctions/SanitizeInput";
import { PhoneSanitize } from "../../supportFunctions/SanitizePhoneNum";
import { useCollapse } from "@/app/supportFunctions/ToggleCollase";
import { Event as RBCEvent, Views } from "react-big-calendar";
import * as XLSX from "xlsx"; //npm install xlsx
import { remove } from "aws-amplify/storage";
import { getUrl } from "aws-amplify/storage";

import _ from "lodash"; // for binary searchability

Amplify.configure(outputs);

// Generate the Amplify client
const client = generateClient<Schema>();

const dateTimeFormat = "YYYY-MM-DD hh:mm";
const dateFormat = "YYYY-MM-DD";
const timeFormat = "hh:mm A";

// Define types for events and modal state
export interface Event {
  start: Date | null; // Allow null for start date
  end: Date | null; // Allow null for end date
  title: string;
  allDay: boolean;
  eventDoc: string | "";
}

export interface Attendee {
  id: string;
  nameFirst: string;
  nameLast: string;
  phoneNumber: string;
  email: string;
  partySize: number;
  isSponsor: boolean;
  supportDetails?: string;
}

interface StorageGetUrlOutput {
  url: string; // The URL string you need
  // Other metadata can be here, depending on the API.
}

const useCalendar = () => {
  const { isContentCollapsed, toggleCollapse } = useCollapse();
  const [currentDate, setCurrentDate] = useState(new Date());
  const [view, setView] = useState<(typeof Views)[keyof typeof Views]>(
    Views.MONTH
  );

  const uploadPath = "events/"; // S3 bucket location

  const [events, setEvents] = useState<Event[]>([]); // Store events fetched from the database
  const [isModalOpen, setIsModalOpen] = useState(false); // Modal visibility
  const [isRSVPModalOpen, setIsRSVPModalOpen] = useState(false); // RSVP Modal visibility
  const [eventTitle, setEventTitle] = useState("");
  const [eventStartDate, setEventStartDate] = useState("");
  const [eventEndDate, setEventEndDate] = useState("");
  const [eventStartTime, setEventStartTime] = useState("");
  const [eventEndTime, setEventEndTime] = useState("");
  const [eventLocation, setEventLocation] = useState("");
  const [eventDetails, setEventDetails] = useState("");
  const [allday, setIsAllDay] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const [selectedEvent, setSelectedEvent] = useState<any>(null);
  const [isEditMode, setIsEditMode] = useState(false);
  const [eventId, setEventId] = useState<string | null>(null);
  const [eventDoc, setEventDoc] = useState("");
  const [eventDocUrl, setEventDocUrl] = useState("");

  const defaultPartySize = 1;
  const [rsvpFName, setRsvpFName] = useState("");
  const [rsvpLName, setRsvpLName] = useState("");
  const [rsvpEmail, setRsvpEmail] = useState("");
  const [rsvpPhone, setRsvpPhone] = useState("");
  const [rsvpAttendeeCount, setRsvpAttendeeCount] = useState(defaultPartySize);

  const [attendees, setAttendees] = useState<Array<Schema["Attendee"]["type"]>>(
    []
  );
  const [listAttendees, setListAttendees] = useState(false);
  const [attendeesList, setAttendeesList] = useState<Attendee[]>([]);
  const [selectedAttendees, setSelectedAttendees] = useState<Set<string>>(
    new Set()
  );
  const [isAttendeesModalOpen, setIsAttendeesModalOpen] = useState(false);
  const [attendeeSearchQuery, setAttendeesSearchQuery] = useState("");
  const [selectedAttendeeSearchOptions, setAttendeesSearchOptions] =
    useState("name");
  const [partySizeTotal, setPartySizeTotal] = useState(0);

  const [sponsor, setSponsor] = useState(false);
  const [support, setSupport] = useState("");

  const { sanitizeInput } = Sanitize();
  const { sanitizePhone } = PhoneSanitize();

  // Fetch events from the database
  useEffect(() => {
    const fetchEvents = async () => {
      try {
        const { data } = await client.models.Event.list();

        const calendarEvents = data.map((event) => {
          const startDateTime = moment(
            `${event.eventStartDate} ${event.eventStartTime || ""}`, // Concatenate date and time
            dateTimeFormat
          );
          const endDateTime = moment(
            `${event.eventEndDate} ${event.eventEndTime || ""}`, // Concatenate date and time
            dateTimeFormat
          );

          return {
            start: startDateTime.isValid() ? startDateTime.toDate() : null, // Handle null times gracefully
            end: endDateTime.isValid() ? endDateTime.toDate() : null,
            title: event.eventTitle ?? "",
            location: event.eventLocation ?? "",
            details: event.eventDetails ?? "",
            allDay: event.allday ?? false,
            eventDoc: event.eventDoc ?? "",
            id: event.id, //Hidden Database ID for editing events
          };
        });
        setEvents(calendarEvents);
      } catch (error) {
        console.error("Error fetching events: ", error);
      }
    };
    listedAttendees();
    fetchEvents();
  }, []);

  function listedAttendees() {
    // Clear the current list before fetching new data
    setAttendeesList([]);
  
    const query = attendeeSearchQuery
      ? { filter: { email: { eq: attendeeSearchQuery } } }
      : {};
  
    client.models.Attendee.list(query)
      .then(async ({ data }) => {
        if (!data || data.length === 0) {
          return; // No attendees found, list is already cleared
        }
  
        const attendeeIds = data.map((attendee) => attendee.id);
  
        // Optional: if selectedEvent is available and you want to scope sponsors to this event
        const sponsorFilter = selectedEvent?.id
          ? {
              and: [
                { eventId: { eq: selectedEvent.id } },
                {
                  or: attendeeIds.map((id) => ({ attendeeId: { eq: id } })),
                },
              ],
            }
          : {
              or: attendeeIds.map((id) => ({ attendeeId: { eq: id } })),
            };
  
        const { data: sponsors } = await client.models.EventSponsors.list({
          filter: sponsorFilter,
        });
  
        const sponsorInfo = sponsors?.reduce((acc, sponsor) => {
          acc[sponsor.attendeeId] = sponsor;
          return acc;
        }, {} as Record<string, any>);
  
        const attendeesWithSponsorInfo = data.map((attendee) => {
          const sponsorDetails = sponsorInfo[attendee.id];
          return {
            ...attendee,
            isSponsor: !!sponsorDetails,
            supportDetails: sponsorDetails?.supportDetails ?? "",
          };
        });
  
        const transformed = transformAttendeesData(attendeesWithSponsorInfo);
        setAttendeesList(transformed);
      })
      .catch((err) => {
        console.error("Error fetching attendees by email:", err);
      });
  }

  // TODO: fetchEventAttendees function for listed attendees
  const handleAttendeeEmalSearch = () => {
    listedAttendees();
    setAttendeesSearchQuery("");
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
  
    // Check if the event title is empty
    if (!eventTitle.trim()) {
      setErrorMessage("Event title cannot be empty.");
      return;
    }
  
    // If start or end time are empty, set them to null
    const startDateTime =
      eventStartDate && eventStartTime
        ? moment(eventStartDate + " " + eventStartTime, dateTimeFormat)
        : null;
    const endDateTime =
      eventEndDate && eventEndTime
        ? moment(eventEndDate + " " + eventEndTime, dateTimeFormat)
        : null;
  
    // Validate time logic only if both are provided
    if (startDateTime && endDateTime && endDateTime.isBefore(startDateTime)) {
      setErrorMessage("End date/time cannot be before start date/time.");
      return;
    }
  
    // Format times to HH:mm (24-hour) to ensure compatibility
    const formattedStartTime = eventStartTime
      ? moment(eventStartTime, ["h:mm A"]).format("HH:mm")
      : null;
  
    const formattedEndTime = eventEndTime
      ? moment(eventEndTime, ["h:mm A"]).format("HH:mm")
      : null;
  
    // Sanitize Inputs
    setEventTitle(sanitizeInput(eventTitle));
    setEventLocation(sanitizeInput(eventLocation));
    setEventDetails(sanitizeInput(eventDetails));
  
    try {
      if (isEditMode) {
  
        // Ensure eventId is not null
        if (!eventId) {
          setErrorMessage("Event ID is missing. Cannot update event.");
          return;
        }
  
        // Proceed with the update
        const updateReply = await client.models.Event.update({
          id: eventId,
          eventTitle,
          eventStartDate,
          eventEndDate,
          eventStartTime: formattedStartTime || null,
          eventEndTime: formattedEndTime || null,
          eventLocation,
          eventDetails,
          eventDoc: eventDoc || null,
          allday,
        });
  
        console.log("Updated Event");
      } else {
        // Create a new event if not in edit mode
        await client.models.Event.create({
          eventTitle,
          eventStartDate,
          eventEndDate,
          eventStartTime: formattedStartTime,
          eventEndTime: formattedEndTime,
          eventLocation,
          eventDetails,
          eventDoc: eventDoc || null,
          allday,
        });
      }
  
      // Fetch updated events using the newly created function
      const updatedEvents = await fetchUpdatedEvents();
  
      setEvents(updatedEvents);
      resetFormFields();
      setIsModalOpen(false);
      setSelectedEvent(false);
      setIsEditMode(false);
      console.log("Event created/updated successfully!");
    } catch (error) {
      console.error("Error creating/updating event: ", error);
    }
  };

  // Function to fetch and process updated events
  const fetchUpdatedEvents = async () => {
    const { data } = await client.models.Event.list();

    const updatedEvents = data.map((event) => {
      const startDateTime = moment(
        `${event.eventStartDate} ${event.eventStartTime || ""}`,
        dateTimeFormat
      );
      const endDateTime = moment(
        `${event.eventEndDate} ${event.eventEndTime || ""}`,
        dateTimeFormat
      );

      return {
        start: startDateTime.isValid() ? startDateTime.toDate() : null, // Handle null times gracefully
        end: endDateTime.isValid() ? endDateTime.toDate() : null,
        title: event.eventTitle ?? "",
        location: event.eventLocation ?? "",
        details: event.eventDetails ?? "",
        allDay: event.allday ?? false,
        eventDoc: event.eventDoc ?? "",
        id: event.id,
      };
    });

    return updatedEvents;
  };

  // Update Event Document
  const updatedEventDoc = async (
    doc: string,
    oldDoc: string,
    eventID: string
  ) => {
    try {
      const result = await client.models.Event.update({
        id: eventID,
        eventDoc: doc,
      });
      // Only remove old file if the path exists
      if (oldDoc) {
        await remove({ path: oldDoc });
      }

      setEventDoc(doc);
      return result;
    } catch (err) {
      console.error("Error creating document: ", err);
    }
  };

  // Reset form fields to their initial state
  const resetFormFields = () => {
    setEventTitle("");
    setEventStartDate("");
    setEventEndDate("");
    setEventStartTime("");
    setEventEndTime("");
    setEventLocation("");
    setEventDetails("");
    setIsAllDay(false);
    setEventId("");
    setErrorMessage("");
    setEventDoc("");
  };

  const resetRSVPFormFields = () => {
    setRsvpFName("");
    setRsvpLName("");
    setRsvpEmail("");
    setRsvpEmail("");
    setRsvpPhone("");
    setErrorMessage("");
    setRsvpAttendeeCount(defaultPartySize);
  };

  // Map events to ensure start and end dates are undefined instead of null
  const mappedEvents = events.map((event) => ({
    ...event,
    start: event.start ?? undefined, // Convert null to undefined
    end: event.end ?? undefined, // Convert null to undefined
  }));

  const handleEventSelect = async (event: any) => {
    try {
      //close and reset all feilds
      resetSelectedEvent();
      // If the same event is clicked again, close the modal by setting selectedEvent to null
      if (selectedEvent && selectedEvent.title === event.title) {
        setSelectedEvent(null); // Close the popup
      } else {
        getRsvpPartyInital(event.id);

        // Fetch the URL for the event document
        let docUrl = "";
        if (event.eventDoc) {
          const result = await generateDocURL(event.eventDoc); // result will be of type StorageGetUrlOutput
          docUrl = result.url.toString(); // Extract the URL from the result
          setEventDocUrl(docUrl);
        }

        setSelectedEvent({
          ...event,
          docURL: docUrl,
        }); // Open the popup with the new event's details
      }
    } catch (error) {
      // Call the refactored function to fetch attendee data
    }
  };

  const generateDocURL = async (doc: string) => {
    const docUrl = await getUrl({
      path: doc,
      options: { expiresIn: 3600 },
    });
    return docUrl;
  };

  const resetSelectedEvent = () => {
    setIsEditMode(false);
    setIsAttendeesModalOpen(false);
    setIsModalOpen(false);
    setPartySizeTotal(0);
    setSponsor(false);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
    resetFormFields();
    setPartySizeTotal(0);
    setIsEditMode(false);
    setSelectedEvent(null); // Clear selected event when modal is closed
    setEventDocUrl("");
  };

  const handleCloseModalBasic = () => {
    setIsModalOpen(false);
    setSelectedEvent(null); // Clear selected event when modal is closed
  };
  const handleCloseRSVP = () => {
    setIsRSVPModalOpen(false);
    setIsModalOpen(false);
    setIsAttendeesModalOpen(false);
    setSelectedEvent(null);
    resetRSVPFormFields();
  };

  const handleAddEventClick = () => {
    setIsModalOpen(false);
    setSelectedEvent(null);
    setIsEditMode(false);
    resetFormFields();
    setIsModalOpen(true);
  };

  const handleEditEventClick = () => {
    resetSelectedEvent();
    
    if (selectedEvent) {
      setEventTitle(selectedEvent.title);
      setEventStartDate(moment(selectedEvent.start).format(dateFormat));
      setEventEndDate(moment(selectedEvent.end).format(dateFormat));
      setEventStartTime(moment(selectedEvent.start).format(timeFormat));
      setEventEndTime(moment(selectedEvent.end).format(timeFormat));
      setEventLocation(selectedEvent.location);
      setEventDetails(selectedEvent.details);
      setIsAllDay(selectedEvent.allDay);
      setEventId(selectedEvent.id);
      setEventDoc(selectedEvent.eventDoc);
      setIsModalOpen(true);
      setIsEditMode(true); // Set to edit mode when editing an existing event
    }
  };

  const handleDeleteEventClick = async () => {
    if (
      selectedEvent &&
      window.confirm("Are you sure you want to delete this event?")
    ) {
      try {
        await deleteSponsorsForEventId(selectedEvent.id); // Delete sponsors first
        await deleteAttendeesForEventId(selectedEvent.id); // Delete attendees for the event
        await client.models.Event.delete({ id: selectedEvent.id }); // Now delete the event itself
        
        // delete S3 Bucket Item
        if(selectedEvent.eventDoc){
          await remove({
            path: selectedEvent.eventDoc,
          })
        }

        handleCloseModal();
        const updatedEvents = await fetchUpdatedEvents();
        setEvents(updatedEvents);
        console.log("Deleted Event");
      } catch (err) {
        console.error("Error deleting event: ", err);
      }
    }
  };

  // Function to delete sponsors for a given event
  const deleteSponsorsForEventId = async (eventId: string) => {
    try {
      // Fetch all EventSponsors entries for the given eventId
      const { data: eventSponsors } = await client.models.EventSponsors.list({
        filter: { eventId: { eq: eventId } },
      });

      if (!eventSponsors || eventSponsors.length === 0) {
        console.log("No sponsors found for this event.");
        return;
      }

      // Deleting the sponsors from the EventSponsors model
      for (const eventSponsor of eventSponsors) {
        await client.models.EventSponsors.delete({ id: eventSponsor.id });
        console.log(`Deleted EventSponsor with ID ${eventSponsor.id}`);
      }

      console.log(`All sponsors for event ${eventId} have been deleted.`);
    } catch (error) {
      console.error(`Error deleting sponsors: ${error}`);
    }
  };

  // Function to delete attendees for a given event
  const deleteAttendeesForEventId = async (eventId: string) => {
    try {
      // Fetch all EventAttentants entries for the given eventId
      const { data: eventAttendants } =
        await client.models.EventAttentants.list({
          filter: { eventId: { eq: eventId } },
        });

      if (!eventAttendants || eventAttendants.length === 0) {
        console.log("No attendees found for this event.");
        return;
      }

      // Extract attendeeIds from the eventAttendants data
      const attendeeIds = eventAttendants.map(
        (relation) => relation.attendeeId
      );

      // Fetch the corresponding attendees
      const { data: attendees } = await client.models.Attendee.list({
        filter: { or: attendeeIds.map((id) => ({ id: { eq: id } })) },
      });

      if (!attendees || attendees.length === 0) {
        console.log("No attendees found.");
        return;
      }

      // Loop through attendees and check if they are attending other events before deleting
      for (const attendee of attendees) {
        const { data: otherEventsAttended } =
          await client.models.EventAttentants.list({
            filter: {
              attendeeId: { eq: attendee.id },
              eventId: { ne: eventId },
            },
          });

        if (otherEventsAttended && otherEventsAttended.length > 0) {
          // If the attendee is attending other events, do not delete them
          console.log(
            `Attendee with ID ${attendee.id} is attending other events. Skipping deletion.`
          );
        } else {
          // If the attendee is not attending any other events, delete them
          await client.models.Attendee.delete({ id: attendee.id });
          console.log(`Deleted attendee with ID ${attendee.id}`);
        }

        // Optionally, you can delete the EventAttentants relationships as well
        for (const eventAttendant of eventAttendants) {
          await client.models.EventAttentants.delete({ id: eventAttendant.id });
          console.log(`Deleted EventAttendant with ID ${eventAttendant.id}`);
        }
      }

      console.log(`All attendees for event ${eventId} have been processed.`);
    } catch (error) {
      console.error(`Error deleting attendees: ${error}`);
    }
  };

  const deleteEventAttendeeId = async (attendeeId: string) => {
    try {
      const { data: eventAttendants } =
        await client.models.EventAttentants.list({
          filter: { attendeeId: { eq: attendeeId } },
        });

      if (!eventAttendants || eventAttendants.length === 0) {
        console.log("No attendees found for this event");
        return;
      }

      for (const eventAttendant of eventAttendants) {
        await client.models.EventAttentants.delete({ id: eventAttendant.id });
      }
    } catch (e) {
      console.error(`Error deleting attendees Join:${e}`);
    }
  };

  const deleteSponsorFromEvent = async (attendeeId: string) => {
    try {
      const { data: eventSponsors } = await client.models.EventSponsors.list({
        filter: { attendeeId: { eq: attendeeId } },
      });

      if (!eventSponsors || eventSponsors.length === 0) {
        console.log("No sponsors found for this attendee");
        return;
      }

      for (const eventSponsor of eventSponsors) {
        await client.models.EventSponsors.delete({ id: eventSponsor.id });
      }
    } catch (e) {
      console.error(`Error deleting sponsor records: ${e}`);
    }
  };

  const handleAttendeeCheckboxChange = (attendeeId: string) => {
    setSelectedAttendees((prevSelected) => {
      const newSelected = new Set(prevSelected);
      if (newSelected.has(attendeeId)) {
        newSelected.delete(attendeeId);
      } else {
        newSelected.add(attendeeId);
      }
      return newSelected;
    });
  };

  const handleBulkDeleteAttendees = async () => {
    if (selectedAttendees.size === 0) {
      alert("No emails selected for deletion.");
      return;
    }
  
    if (
      window.confirm("Are you sure you want to delete the selected Attendees?")
    ) {
      try {
        // Use attendeesList instead of stale attendees state
        const attendeesToDelete = attendeesList.filter((attendee) =>
          selectedAttendees.has(attendee.id)
        );
  
        for (const attendee of attendeesToDelete) {
          // Use full object if possible
          await client.models.Attendee.delete(attendee);
  
          // Remove relations
          await deleteEventAttendeeId(attendee.id);
          await deleteSponsorFromEvent(attendee.id);
  
          console.log(`Deleted attendee with ID ${attendee.id}`);
        }
  
        // Clear selection
        setSelectedAttendees(new Set());
  
        // Refresh the list
        setAttendeesList([]); // Clear immediately to trigger re-render
        await listedAttendees();
  
      } catch (e) {
        console.error("Error deleting Attendees:", e);
      }
    }
  };

  const handleRSVPEventClick = () => {
    setIsAttendeesModalOpen(false);
    setIsRSVPModalOpen(true);
  };

  const handleAdminSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (rsvpFName === "" || rsvpLName === "") {
      setErrorMessage(" * First name and last name are required.");
      return;
    }

    //sanitize inuts
    setRsvpFName(sanitizeInput(rsvpFName));
    setRsvpLName(sanitizeInput(rsvpLName));
    setRsvpEmail(sanitizeInput(rsvpEmail).toLowerCase());

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(rsvpEmail)) {
      setErrorMessage(` * Invalid email ex. sltfire@gmail.com`);
      return;
    }

    // Validate phone format
    const sanitizedNum = sanitizePhone(rsvpPhone);

    if (sanitizedNum === null) {
      setErrorMessage(" * Invalid phone format ex. 555-555-555.");
      return;
    }

    setRsvpPhone(sanitizedNum);

    try {
      // Fetch event-attendee relationships for the specific event
      const { data: eventAttendants } =
        await client.models.EventAttentants.list({
          filter: { eventId: { eq: selectedEvent.id } },
        });

      if (eventAttendants && eventAttendants.length > 0) {
        // Extract attendee IDs from the relationships
        const attendeeIds = eventAttendants.map(
          (relation) => relation.attendeeId
        );
        // Create an 'or' condition for all attendee IDs
        const filterCondition = attendeeIds.map((id) => ({ id: { eq: id } }));

        // Fetch attendee details based on IDs using 'or' conditions
        const { data: attendees } = await client.models.Attendee.list({
          filter: { or: filterCondition },
        });

        const checkRsvpList = attendees.map((attendee) => ({
          id: attendee.id, // Ensure no null values
          nameFirst: attendee.nameFirst || "", // Ensure no null values
          nameLast: attendee.nameLast || "",
          phoneNumber: attendee.phoneNumber || "",
          email: attendee.email || "",
          partySize: attendee.partySize || defaultPartySize,
        }));

        //sort by Rsvp list by email address
        const sortedRsvpList = checkRsvpList.sort((a, b) => {
          if (a.email < b.email) return -1;
          if (a.email > b.email) return 1;
          return 0;
        });

        const index = _.sortedIndexOf(
          sortedRsvpList.map((attendee) => attendee.email),
          rsvpEmail //search for a matching email address
        );

        if (index !== -1) {
          // Email has been found
          setErrorMessage(
            "This Email has already been used to RSVP to this Event"
          );
          return;
        }
      }

      const attendeeResult = await client.models.Attendee.create({
        nameFirst: rsvpFName,
        nameLast: rsvpLName,
        phoneNumber: rsvpPhone,
        email: rsvpEmail,
        partySize: rsvpAttendeeCount,
      });

      const attendee = attendeeResult?.data; // Ensure the data exists
      if (attendee) {
        if (selectedEvent.id) {
          await client.models.EventAttentants.create({
            eventId: selectedEvent.id, // Event ID from selected event
            attendeeId: attendee.id, // Link attendee by email (or use attendee.id)
          });
          // If the attendee is sponsoring the event, create a sponsorship record
          if (sponsor) {
            await client.models.EventSponsors.create({
              eventId: selectedEvent.id,
              attendeeId: attendee.id,
              supportDetails: support, // Use the inquiry text for the sponsorship
            });
          }
        }
      }
    } catch (error) {
      console.error("Error RSVP to event: ", error);
    }

    setIsRSVPModalOpen(false);
    resetRSVPFormFields();
  };
  const handleRSVPSubmit = async (e: React.FormEvent, formEventId: string) => {
    e.preventDefault();

    if (rsvpFName === "" || rsvpLName === "") {
      setErrorMessage(" * First name and last name are required.");
      return;
    }

    //sanitize inuts
    setRsvpFName(sanitizeInput(rsvpFName));
    setRsvpLName(sanitizeInput(rsvpLName));
    setRsvpEmail(sanitizeInput(rsvpEmail).toLowerCase());

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(rsvpEmail)) {
      setErrorMessage(` * Invalid email ex. sltfire@gmail.com`);
      return;
    }

    // Validate phone format
    const sanitizedNum = sanitizePhone(rsvpPhone);

    if (sanitizedNum === null) {
      setErrorMessage(" * Invalid phone format ex. 555-555-555.");
      return;
    }

    setRsvpPhone(sanitizedNum);

    try {
      // Fetch event-attendee relationships for the specific event
      const { data: eventAttendants } =
        await client.models.EventAttentants.list({
          filter: { eventId: { eq: formEventId } },
        });

      if (eventAttendants && eventAttendants.length > 0) {
        // Extract attendee IDs from the relationships
        const attendeeIds = eventAttendants.map(
          (relation) => relation.attendeeId
        );
        // Create an 'or' condition for all attendee IDs
        const filterCondition = attendeeIds.map((id) => ({ id: { eq: id } }));

        // Fetch attendee details based on IDs using 'or' conditions
        const { data: attendees } = await client.models.Attendee.list({
          filter: { or: filterCondition },
        });

        const checkRsvpList = attendees.map((attendee) => ({
          id: attendee.id, // Ensure no null values
          nameFirst: attendee.nameFirst || "", // Ensure no null values
          nameLast: attendee.nameLast || "",
          phoneNumber: attendee.phoneNumber || "",
          email: attendee.email || "",
          partySize: attendee.partySize || defaultPartySize,
        }));

        //sort by Rsvp list by email address
        const sortedRsvpList = checkRsvpList.sort((a, b) => {
          if (a.email < b.email) return -1;
          if (a.email > b.email) return 1;
          return 0;
        });

        const index = _.sortedIndexOf(
          sortedRsvpList.map((attendee) => attendee.email),
          rsvpEmail //search for a matching email address
        );

        if (index !== -1) {
          // Email has been found
          setErrorMessage(
            "This Email has already been used to RSVP to this Event"
          );
          return;
        }
      }

      const attendeeResult = await client.models.Attendee.create({
        nameFirst: rsvpFName,
        nameLast: rsvpLName,
        phoneNumber: rsvpPhone,
        email: rsvpEmail,
        partySize: rsvpAttendeeCount,
      });

      const attendee = attendeeResult?.data; // Ensure the data exists
      if (attendee) {
        if (formEventId) {
          await client.models.EventAttentants.create({
            eventId: formEventId, // Event ID from selected event
            attendeeId: attendee.id, // Link attendee by email (or use attendee.id)
            isSponsor: sponsor,
          });
          // If the attendee is sponsoring the event, create a sponsorship record
          if (sponsor) {
            await client.models.EventSponsors.create({
              eventId: formEventId,
              attendeeId: attendee.id,
              supportDetails: support, // Use the inquiry text for the sponsorship
            });
          }
        }
      }
    } catch (error) {
      console.error("Error RSVP to event: ", error);
    }

    setIsRSVPModalOpen(false);
    resetRSVPFormFields();
  };

  const fetchAttendeesForEvent = async (eventId: string) => {
    try {
      // Fetch event-attendee relationships for the specific event
      const { data: eventAttendants } =
        await client.models.EventAttentants.list({
          filter: { eventId: { eq: eventId } },
        });

      if (eventAttendants && eventAttendants.length > 0) {
        // Extract attendee IDs from the relationships
        const attendeeIds = eventAttendants.map(
          (relation) => relation.attendeeId
        );

        // Create an 'or' condition for all attendee IDs
        const filterCondition = attendeeIds.map((id) => ({ id: { eq: id } }));

        // Fetch attendee details based on IDs using 'or' conditions
        const { data: attendees } = await client.models.Attendee.list({
          filter: { or: filterCondition },
        });

        // Fetch sponsor details for the attendees who are sponsors
        const { data: eventSponsors } = await client.models.EventSponsors.list({
          filter: {
            and: [
              { eventId: { eq: eventId } }, // Filter by eventId
            ],
          },
        });

        // Map sponsor information to a dictionary based on attendeeId
        const sponsorInfo = eventSponsors?.reduce((acc, sponsor) => {
          acc[sponsor.attendeeId] = sponsor;
          return acc;
        }, {} as Record<string, any>);

        // Combine attendee details with sponsor data
        const attendeesWithSponsorInfo = attendees.map((attendee) => {
          const sponsorDetails = sponsorInfo[attendee.id];

          // Safely check sponsorDetails and handle null values
          const isSponsor = sponsorDetails ? true : false;
          const supportDetails = sponsorDetails?.supportDetails ?? ""; // Use empty string if null or undefined

          return {
            ...attendee,
            isSponsor, // Set to true if sponsorDetails exist, false otherwise
            supportDetails, // Set to supportDetails or empty string if null or undefined
          };
        });

        // Return combined attendees data with sponsor information
        return attendeesWithSponsorInfo;
      } else {
        console.log("No attendees found for this event.");
        return []; // Return empty array if no attendees are found
      }
    } catch (error) {
      console.error("Error fetching attendees:", error);
      return []; // Return empty array in case of error
    }
  };

  const calculateTotalAttendees = (
    attendees: { partySize: number }[]
  ): number => {
    return attendees.reduce((total, attendee) => total + attendee.partySize, 0);
  };

  const transformAttendeesData = (
    attendees: any[]
  ): {
    id: string;
    nameFirst: string;
    nameLast: string;
    phoneNumber: string;
    email: string;
    partySize: number;
    isSponsor: boolean;
    supportDetails: string;
  }[] => {
    return attendees.map((attendee) => ({
      id: attendee.id, // Ensure no null values
      nameFirst: attendee.nameFirst || "", // Ensure no null values
      nameLast: attendee.nameLast || "",
      phoneNumber: attendee.phoneNumber || "",
      email: attendee.email || "",
      partySize: attendee.partySize || defaultPartySize,
      isSponsor: attendee.isSponsor || false,
      supportDetails: attendee.supportDetails || "",
    }));
  };

  const getRsvpPartyInital = async (eventId: string) => {
    const attendees = await fetchAttendeesForEvent(eventId);
    if (attendees.length > 0) {
      // Use the helper function to transform the attendees data
      const transformedAttendees = transformAttendeesData(attendees);

      // Calculate total attendees using the helper function
      const totalAttendees = calculateTotalAttendees(transformedAttendees);

      setPartySizeTotal(totalAttendees);
    }
    return;
  };

  const fetchEventAttendees = async (eventId: string) => {
    try {
      // Call the refactored function to fetch attendee data
      const attendees = await fetchAttendeesForEvent(eventId);
      if (attendees.length > 0) {
        // Use the helper function to transform the attendees data
        const transformedAttendees = transformAttendeesData(attendees);
        // Set state for attendees list
        setAttendeesList(transformedAttendees);
        setIsAttendeesModalOpen(true); // Open modal to display attendees
      } else {
        setAttendeesList([]); // In case no attendees are found
        setIsAttendeesModalOpen(true);
      }
    } catch (error) {
      console.error("Error fetching attendees:", error);
    }
  };

  // Handle the "List Attendees" button click
  const handleListAttendeesClick = async () => {
    if (selectedEvent?.id) {
      await fetchEventAttendees(selectedEvent.id); // Fetch attendees for the selected event
      setIsModalOpen(false); // Close the "Create a New Event" modal
    } else {
      console.error("No event selected for listing attendees.");
    }
  };

  // Close the attendees modal
  const handleCloseAttendeesModal = () => {
    setIsAttendeesModalOpen(false);
    setAttendeesList([]);
    setIsModalOpen(false);
    setSelectedEvent(null);
    resetFormFields();
  };

  // Calendar Navigation
  const handleNavigate = (newDate: Date) => {
    setCurrentDate(newDate);
  };

  // Handle changing the calendar view
  const handleViewChange = (newView: string) => {
    setView(newView as (typeof Views)[keyof typeof Views]); // Proper casting
  };

  // Export to Excel
  const exportToExcel = (attendeesList: Attendee[], eventName: string) => {
    // Map the attendees list to a format suitable for Excel export
    const data = attendeesList.map((attendee) => ({
      Name: `${attendee.nameFirst} ${attendee.nameLast}`,
      Email: attendee.email,
      Phone: attendee.phoneNumber,
      "Party Size": attendee.partySize,
      Sponsor: attendee.isSponsor ? "X" : "",
      "Support Info": attendee.supportDetails || "",
    }));

    // Create a new worksheet
    const ws = XLSX.utils.json_to_sheet(data);

    // Calculate auto column widths
    const colWidths: number[] = data.reduce((acc, row) => {
      Object.keys(row).forEach((key) => {
        const cellValue = row[key as keyof typeof row]; // Ensure 'key' is treated as a valid key
        const columnWidth = cellValue ? String(cellValue).length : 10; // Basic length calculation
        acc[colIndex(key)] = Math.max(acc[colIndex(key)] || 10, columnWidth); // Update max width
      });
      return acc;
    }, [] as number[]); // Explicitly define accumulator as a number array
    ws["!cols"] = colWidths.map((width) => ({ wch: width }));

    // Add borders to all cells (including headers)
    const range = ws["!ref"];
    if (range) {
      const decodedRange = XLSX.utils.decode_range(range); // Get range of the data
      for (let row = decodedRange.s.r; row <= decodedRange.e.r; row++) {
        for (let col = decodedRange.s.c; col <= decodedRange.e.c; col++) {
          const cellAddress = { r: row, c: col };
          const cellRef = XLSX.utils.encode_cell(cellAddress);

          if (!ws[cellRef]) {
            ws[cellRef] = {}; // Create empty cell if it does not exist
          }

          // Add thicker border to each cell
          ws[cellRef].s = {
            border: {
              top: { style: "medium", color: { rgb: "000000" } },
              left: { style: "medium", color: { rgb: "000000" } },
              bottom: { style: "medium", color: { rgb: "000000" } },
              right: { style: "medium", color: { rgb: "000000" } },
            },
          };
        }
      }
    }

    // Create a new workbook and append the worksheet
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Attendees");

    // Set the file name based on the event name
    const fileName = `${eventName}_attendees.xlsx`;

    // Export the Excel file with the dynamic file name
    XLSX.writeFile(wb, fileName);
  };

  // Helper function to convert object keys to column indexes
  function colIndex(key: string): number {
    const colMap: { [key: string]: number } = {
      Name: 0,
      Email: 1,
      Phone: 2,
      "Party Size": 3,
      Sponsor: 4,
      "Support Info": 5,
    };
    return colMap[key] || 0; // Default to 0 if the key is unknown
  }

  return {
    attendees,
    events,
    view,
    currentDate,
    isModalOpen,
    isRSVPModalOpen,
    eventTitle,
    eventStartDate,
    eventEndDate,
    eventStartTime,
    eventEndTime,
    eventLocation,
    eventDetails,
    allday,
    selectedEvent,
    errorMessage,
    mappedEvents,
    isEditMode,
    eventId,
    rsvpFName,
    rsvpLName,
    rsvpEmail,
    rsvpPhone,
    rsvpAttendeeCount,
    listAttendees,
    attendeesList,
    isAttendeesModalOpen,
    isContentCollapsed,
    attendeeSearchQuery,
    selectedAttendeeSearchOptions,
    partySizeTotal,
    selectedAttendees,
    sponsor,
    support,
    uploadPath,
    eventDoc,
    eventDocUrl,
    generateDocURL,
    setEventDocUrl,
    updatedEventDoc,
    setEventDoc,
    setSponsor,
    setSupport,
    setSelectedAttendees,
    setView,
    setPartySizeTotal,
    setAttendees,
    setAttendeesSearchOptions,
    setAttendeesSearchQuery,
    setIsAttendeesModalOpen,
    setAttendeesList,
    setListAttendees,
    setEventId,
    setIsModalOpen,
    setIsRSVPModalOpen,
    setEventTitle,
    setEventStartDate,
    setEventEndDate,
    setEventStartTime,
    setEventEndTime,
    setEventLocation,
    setEventDetails,
    setIsAllDay,
    setErrorMessage,
    setSelectedEvent,
    setRsvpFName,
    setRsvpLName,
    setRsvpEmail,
    setRsvpPhone,
    setRsvpAttendeeCount,
    handleSubmit,
    handleRSVPSubmit,
    resetFormFields,
    handleEventSelect,
    handleCloseModal,
    handleCloseRSVP,
    handleRSVPEventClick,
    handleAddEventClick,
    handleCloseModalBasic,
    handleEditEventClick,
    handleDeleteEventClick,
    handleCloseAttendeesModal,
    handleListAttendeesClick,
    handleNavigate,
    handleViewChange,
    handleAttendeeCheckboxChange,
    handleBulkDeleteAttendees,
    handleAdminSubmit,
    handleAttendeeEmalSearch,
    toggleCollapse,
    exportToExcel,
  };
};

export default useCalendar;
